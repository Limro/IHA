\documentclass{article}

\include{Preamble}

\begin{document}
\section{Reactor Pattern}

The Reactor architectural pattern allows event-driven applications to demultiplex \& dispatch service requests that are delivered to an application from one or more clients.

Generelt:
\begin{itemize}
	\item Bruges primært til servere, der \textit{venter} på events.
	Den checker dog hele tiden på, om der er kommet noget nyt.
	\item \code{Reactor} håndtere events til forskellige processer
	\item Modtages synkront og serielt
	\item Hvert event sorteres af en \code{Multiplex}er (baseret på indhold) og uddeles af en \code{Dispatcher} til en process. 
	Alle applikationsspecifike funtioner udføres af specifikke \code{EventHandler}s.
	\item Inversion of Control bruges (dependency (interface) injection) og gøre koden generisk. Se \codeTitle \ref{lst:DI}.
\end{itemize}

Implementering:
\begin{itemize}
	\item Klassen \code{Reactor} bruger GoF Bridge pattern (pointer til implementering -- også kaldet \emph{pimpl idiom}, da der kun er én implementering). 
	\item Klassen \code{Reactor} bruges som en Singleton.
	\item Klassen \code{Demultiplexter}'s \code{select()} har "file descripter set"    parametre. 
	Disse checkes for \code{READ}, \code{WRITE}, exceptions og time outs.
\end{itemize}

Fordele:
\begin{itemize}
	\item Separation of concerns
	\item[] Afkobler \code{Demux} og \code{Dispatcher} fra applikationsspecifik kode
	
	\item Modularity and reuseability
	\item[] Hvert event er sit eget komponent.

	\item Portability
	\item[] \code{Reactor} er frakoblet low-level kode og kan bruges af højre levels.

	\item Har et super godt samspil med \code{Wrapper Facade} pattern til low-level.
\end{itemize}

Ulemper:
\begin{itemize}
	\item Semi-svær at debugge.
	\item Single-threaded applikationer standser \code{Reactor} til de er færdige.
\end{itemize}

Andet:
\begin{itemize}
	\item \code{Reactor} kan bruges på clienten, hvis denne har nogle faste mønstre der kan sendes og modtages data i.
	I modsætning til serveren vil den kun kalde \code{HandleEvent()} én gang og exite.
	\item Sammensæt med Acceptor pattern, således serveren kalder accepter, og den registrere et gyldigt event.
	\item \code{Proactor}\fxnote{Skriv om dette}
\end{itemize}

\begin{lstlisting}[caption=Bridge / interface injection, style=Code-C++, label=lst:DI]
Reactor(IClass *impl)
{ impl->getData(); }
\end{lstlisting}

\begin{figure}[hbtp]
\centering
\includegraphics[width=0.9 \textwidth]{Reactor}
\end{figure}





\newpage
\section{Paradigms for Distributed Communication}

Space, time and flow:
\begin{itemize}
	\item Space decoupling betyder, at en publisher ikke kender til sine subscribers.
	Der er en service der klarer dette for den.

	\item Time decoupling betyder, at beskeder fra en publisher ikke skal komme per omgående til subscriber.
	Når først pubslisher udgiver, kan der gå tid til subscriber modtager.

	\item Flow decoupling betyder, at den forstyrrer når den vil?\fxnote{Check om dette er rigtigt}
\end{itemize}


RMI og publish/subscriber:
\begin{itemize}
	\item RMI -- Remote Method Invocation betyder, at du over et netværk kan aktivere en kommando, der bliver eksikveret (og muligvis sendt tilbage).

	\begin{itemize}
	 	\item Understøttes af Java, CORBA og Mircrosoft's DCOM
	 	\item Dur kun mellem 2 maskiner.
		\item Time og space er coupled :(
		\item Flow couple er meget stærk på consumer siden.
		\begin{itemize}
		 	\item Er ikke stærkt, hvis producer ikke forventer et svar
		 	\item Altså asynk
		 \end{itemize} 
	\end{itemize} 

	\item Publisher/Subscriber
	\begin{itemize}
		\item Decoupler space, time og flow ved at lade alt køre i en kanal (Socket/kø)
		\item The channel decouples
	\end{itemize}
\end{itemize}

\begin{figure}[ht]
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{RMI}
\caption{RMI}
\label{fig:figure1}
\end{minipage} 						% No linebreak from here
\hspace{0.5cm}						% ...
\begin{minipage}[b]{0.45\linewidth}	% to here. They will over-under with linebreak
\centering
\includegraphics[width=\textwidth]{PS}
\caption{Publish/Subscribe}
\label{fig:figure2}
\end{minipage}
\end{figure}


Skal vi fortælle om de 3 versioner af p/s eller de andre, ringe løsninger?









\newpage
\section{Acceptor/Connector Pattern}


\subsection{Explain the "Acceptor/connector" pattern mechanism}
Acceptor-connector decoupler forbindelsen og services-laget.
Når først en forbindelse er accepteret, oprettes en seperat stream mellem de to.
Herefter vil \code{Reactor}'en (i et \code{while(1)}) bede \code{ServiceHandler}'en udføre sine opgaver.

Acceptor:
\vspace{-10pt}
\begin{itemize}
	\item Ligger på serveren.
	\item Modtager kun eventet \code{Accept()}  ment til den aktuelle \code{Acceptor}.
	\item Opretter konkrete \code{ServiceHandler}'re for events med \code{template}s  -- disse indeholder IP og port.
	\item Alle andre beskeder sendes direkte til \code{ServiceHandler} fra peer og aktiveres af \code{Dispatcher}'ens \code{HandleEvent()}.
\end{itemize}

Connector:
\vspace{-10pt}
\begin{itemize}
	\item Connector ligger på clienterne.
	\item Connectoren opretter en \code{ServiceHandler}, der snakker med Acceptorens \code{ServiceHandler}.
	\item Sender predefinere beskeder i form af \code{READ}, \code{WRITE} og \code{CONNECT} til serveren, hvor \code{CONNECT} binder \code{ServiceHandler}ne sammen.
	\item Beskederne sendes igennem en \code{ServiceHandler}en.
\end{itemize}



\subsection{Describe when to use an acceptor, a connector or both patterns in a node}
\begin{itemize}
	\item Acceptor bruges i alle servere, der har forskellige opgaver.
	Det vil forsimple besked-tilgangen og der kan oprettes seperate \code{ServiceHandler}e til forskellige connections.
	\item Connector bruges, hvis man har de tilsvarende beskeder til Acceptoren. 
	Dette vil sikre, at der ikke sendes beskeder der ikke må sendes?

	\item Brug begge i én node, når du ønsker p2p forbindelse i form af torrents and the likes.
\end{itemize}



\subsection{Describe the difference between a synchronous and an asynchronous connector}
Synkron:
\vspace{-10pt}
\begin{itemize}
	\item 
\end{itemize}

Asynkron:
\vspace{-10pt}
\begin{itemize}
	\item Clienter der har langsom forbindelse får ikke serveren til at vente.
	\item Clienter der er single-threaded kigger blot i en kø 
	\item Hvis (p2p) clienten har mange peers, som kobler til i tilfældig orden.
	\item Bruges sammen med en Proactor
	\item Generelt mange forbindelser vil 
\end{itemize}







\newpage
\section{Proactor and ACT Patterns}

\subsection{Explain the "Proactor" pattern mechanism and its interaction with the  
Asynchronous Completion Token (ACT) pattern}

Asynchronous Completion Token (ACT):
\vspace{-10pt}
\begin{itemize}
	\item Design pattern.
	\item Tillader effiktiv demultiplx og processering ved asynkrone operationer.
	\item Vil ved færdiggørelse returnere ACT (og resultat).
\end{itemize}

Proaktor:
\vspace{-10pt}
\begin{itemize}
	\item Erstatter \code{Reactor} som dispatcher.
	\item Sætter asynk-tråde til at udfører store opgaver og fortsætter med mindre i mellemtiden.
	\item Når en asynk bliver færdig, skubbes denne ind i en event-kø. 
	\item Denne gør Proactoren opmærksom på, at det er færdig og skubbes frem i køen af \code{HandleEvent()}.
	\item Herefter sendes dette videre til en \code{CompletionHandler} (det samme som ServiceHandler).
\end{itemize}


\subsection{Describe for what and when these pattern are used}

Proactor:
\vspace{-10pt}
\begin{itemize}
	\item Ved long-duration oprerationer, der eksikveres asynk.
	\item Hvis man derimod lader en asynk tråd håndtere lange kald, kan små kald passere imens. (forstil dig noget MatLab kode skal køre).
\end{itemize}


\subsection{Describe the benefits in comparison with the use of a Reactor pattern in combination with a concurrency pattern}


\begin{itemize}
	\item I reaktor pattern skal alt håndteres på lige fod. Det skal proactor ikke.
	\item Der er bedre OS portablility.
	\item Der laves færre tråde, da nogle \code{CompletionHandler}s ikke behøver tråde (alle concurrency vil).
	\item Dette undlader context switching.
\end{itemize}







































\end{document}