\documentclass[10pt, a4]{Memoir}

\include{Preamble}

\begin{document}


\chapter{ARDI}

\section{Lesson 2}

\subsection{Changing environments}
\begin{itemize}
\item With relational database
\subitem Could be windmills and collecting data from many mills

\item With external information providers
	\begin{itemize}
	\item RMI: kalder et objekt på en anden maskine.
	\item RPC: kalder en funktion på en anden maskine.
	\end{itemize}

\item with Internet application
	\begin{itemize}
	\item[] Slide 4
	\item Server can place a cookie on the computer, due to bad connection
	\item QoS (latency, performance) not guarenteed. 
	\end{itemize}

\item QoS
	\begin{itemize}
	\item slide 5
	\item CORBA tries to implement it in version 3.0
	\end{itemize}

\item Nomadic mobility (telefoner)
	\begin{itemize}
	\item slide 6
	\item Lysmaster med wifi hotspots
	\item Det mobile object kan skifte driver afhængig af hvor den er, eller hvad der om den.
	\end{itemize}

\item Qbiquitos/pervasive computing
	\begin{itemize}
	\item slide 7
	\item Adhoc network (spontant netværk)
	\subitem En masse sensorer laver et netværk og opsamler data 	
	\subitem Et netværk i alle biler
	\item At give en lile enhed en IPv6 er spild af plads, hvis den blot smides ud senere.
	\end{itemize}
\end{itemize}

\subsection{Programming Models}
\begin{itemize}
\item Client-server
	\begin{itemize}
	\item Du puller data
	\end{itemize}

\item Publish/subscribe
\item Peer-to-peer
\item Async interaction
	\begin{itemize}
	\item slide 9/10
	\item RMI and RPC
	\end{itemize}

\item Shared memory
	\begin{itemize}
	\item slide 11
	\item Will look like shared memory for multiple computers (Dropbox - data forsvinder og rettes med det samme / Google Docs).
	\item JavaSpace does the same trick
	\end{itemize}

\item Mobile code and mobile agents
	\begin{itemize}
	\item slide 12
	\item Travels nodes to find out where to go next
	\item Will seem autonomous.
	\end{itemize}

\end{itemize}


\subsection{Arkitektur}

\begin{itemize}
\item Distributed transparency
	\begin{itemize}
	\item slide 13
	\item I stedet for 2 funktioner på én maskine er der to funktioner på 2 maskiner (én hver). Disse kan snakke sammen på samme måde
	\subitem Nogle af disse har exceptions implementeret
	\end{itemize}

\item Layering
	\begin{itemize}
	\item Man tilgår kun laget over eller under (kan også have adgang til alle lag)
	\end{itemize}

\item Monolithic 
	\begin{itemize}
	\item Small devices der skal bruge det - Corba har det, men er alt for stort!
	\end{itemize}

\end{itemize}

\subsection{Dynamic configurations}

\begin{itemize}
\item Disconnect operations
	\begin{itemize}
	\item slide 16
	\item Bluetooth's nyeste version (BLE -- low energy) disconnecter på meget kort forbindelsen før opretelse igen for at spare strøm.
	\end{itemize}

\item Adaptive applications
	\begin{itemize}
	\item Lav internethastighed kan give lidt net
	\end{itemize}

\end{itemize}






\section{SAP 1}
Der er 3 actors i systemet:
\begin{itemize}
\item Der er en infrastructure, som bruges af en app (og eges af infrastruktur owner). Denne har derfor en høj abstraction.
\item Applikations owner ønsker så noget lavet i infrastrukturen. 
Dette gør Component owner sammen med infrastruktur owner.
\item Ved at gøre det multiparadigm kan mange forskellige elementer hentes ind til infrastrukturen.
\end{itemize}

\newpage
\section{Lesson 3 -- Reactor pattern}

Kan bruges ved Embedded system og netværk.
\\
Det fungerer som følger:

\begin{itemize}
\item En til flere clienter forsøger at forbinde til en server
\item Reactor ligger på server (men kan også ligge på clienten)

\item Serveren venter på noget sker og gør ikke noget indtil et event (connect / read $dots$) kommer ind.
\subitem Den bruger main thread

\item Sockets er inkapslet i et \code{handle}
\item Hvert request er processeret synkron og i seriel
\subitem Ved modtagelse laves et demultiplex og eventet sendes til den service der processerer dem.
\item Bruger IoC
\end{itemize}
Der er følgende klasser:

\begin{itemize}
\item EventHandler
	\begin{itemize}
	\item handle\_event()
	\item get\_handle()
	\end{itemize}
\item[] Denne del er et interface for konkrete eventhandlers fra clienter.
\item[] Den har et 1-til-1 ejerskab med \code{Handle}-klassen.

\item Reacter
	\begin{itemize}
	\item Handle\_events()
	\item register\_handler()
	\item remove\_handler()
	\end{itemize}
\item[] De sidste to tilføjer og fjerner den enkelte EventHandler's handle
\item[] \code{Reactor} dispatcher flere EventHandler
\item[] \code{Reactor} er en singleton

\item Demultiplexer
	\begin{itemize}
	\item select()
	\end{itemize}
\item[] Bruges af \code{Reactor}
\end{itemize}
Implementation
\begin{enumerate}
\item Definer \code{EventHandler} interface
\subitem Slide 12-13
\item Definer \code{reactor} interface
\subitem Slide 14
\subitem \code{register\_handler}'s overloading kunne klares med en default parameter for \code{Handle}
\item Implementer \code{reactor} interface
\item Beslut antal af \code{reactors} der skal bruges
\subitem Slide 19
\item Implementer konkrete \code{EventHandler}s
\end{enumerate}
Fordele:

\begin{itemize}
\item Slide 25
\item Kan bruges på flere OSs
\item Kan bruges som et modul
\item Kan serilizeres
\end{itemize}
Ulemper:
\begin{itemize}
\item Slide 26
\item Kan være svært at teste
\item Single thread kan stoppe andre i at køre (duhh)
\end{itemize}






\newpage
\section*{Lesson 5 -- Aceeptor/Connector pattern}

En client, $C$, en server, $S$, og to peers, $p1, p2$.
\begin{itemize}
	\item $C$ skal blot kommunikere med $S$ eller omvendt.
	\item $S$ kan have en $reactor$ og dispatche $event handlers$ (kan også på $C$, men det er lidt underligt, hvis den ikke skal andet end forbinde til serveren. Til $p1$ er det fint at have den).
	\item $Acceptor$ og $Connector$ placeres over Wrapper'en.
	\item $C$ har connector, $S$ har acceptor, $p1$ og $p2$ har begge
	\item Når forbindelsen mellem $p1$ og $p2$ er sat op har de en $logical channel$ / \code{sock\_stream} 
	\item Over \code{Acceptor} pg \code{Connector} laves selve applikationen.
	\item \code{Reactor} og \code{Proactor}'en kaldes tilsammen \code{dispatcher}.
	\item En \code{Service handler} er et interface der bruges sammen med \code{Acceptor} og \code{Connector}'en.
	\item Alle 3 arver fra \code{Event Handler} sammen med \code{Reactor}'en.
\end{itemize}
Applikationer for \code{Service Handler}
\begin{itemize}
	\item Slide 45
	\item S
\end{itemize}


\newpage
\section*{Lesson 6 -- Requirements og arkitektur}

\begin{itemize}
	\item Funktionelle krav beskrives med Use Cases
	\item Non-functionelle krav \dots
	\begin{itemize}
		\item Distribution
		\item performance
		\item Svalability
		\item Availability
		\item Reliability
		\item Portability
		\item Dynamic configuration
		\item Heterogeneity and lagacy systems
		\item Security
		\item \dots
	\end{itemize}
	\item Når UC'erne er lavet til en model, kan der laves forskellige løsninger (med eller uden distribuerede systemer).
	\item Validation technique: ATAM (Architecture Tradeoff Analysis Method).
	\begin{itemize}
		\item Processen beskrives på slide 8
		\item Phase 4 er design-delen, da man må undvære noget for noget andet (flere udviklere for nok design koster penge).
	\end{itemize}
\end{itemize}































\end{document}