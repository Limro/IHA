\documentclass[Main]{subfiles}

\begin{document}


\codeTitle \ref{lst:gfPol2Table} will generate a code table for the Galois Field, based on the input polynomial vector.
The output will be a list of alphas, $\alpha$, (with 0 and 1), what each alpha corresponds to and the binary representation of the alphas.
\begin{lstlisting}[caption=gfPol2Table, style=Code-Matlab, label=lst:gfPol2Table]
function [minPol b] = minimumPoly(E,P,V,root)
% Returns the minimum polynomial and the conjugated roots, given the
% exponential and polynomial form of the Galois Field, and one root.
% [minPol b] = minimumPoly(E,P,root)
% See gfPol2Table for E and P parameter.
%
% Note: 
% root = 0 -> X     (Not supported)
% root = 1 -> 1 + X (Not supported)
%
% Ex: 
% [E V P] = gfPol2Table([...]);
% [minPol b] = minimumPoly(E,P,a^3);

m = log2(length(E));
syms X;
% All conjugate roots for root:
b = conjugateRoots2(V, root);

% Minimal polynomium:
minPol = 1;
for i=1:length(b)
    minPol = minPol * (X+b(i));
end
 
% Substitute all exponential forms with polynomial form and reduce:
while degree(subs(minPol,X,1)) >= m
    minPol = subs(minPol,E,P);
    minPol = expand(minPol);
end

% Modulo 2:
minPol = mod2partly(minPol);
end
\end{lstlisting}



\codeTitle \ref{lst:minimumPoly} will generate the minimum polynomials for the root, based on the the output of alphas from \codeTitle \ref{lst:gfPol2Table}.
The ouput is the minimal polynomial and conjugated roots.

\begin{lstlisting}[caption=MinimumPoly, style=Code-Matlab, label=lst:minimumPoly]
function [minPol b] = minimumPoly(E,P,V,root)
% Returns the minimum polynomial and the conjugated roots, given the
% exponential and polynomial form of the Galois Field, and one root.
% [minPol b] = minimumPoly(E,P,root)
% See gfPol2Table for E and P parameter.
%
% Note: 
% root = 0 -> X     (Not supported)
% root = 1 -> 1 + X (Not supported)
%
% Ex: 
% [E V P] = gfPol2Table([...]);
% [minPol b] = minimumPoly(E,P,V,a^3);

m = log2(length(E));
syms X;
% All conjugate roots for root:
b = conjugateRoots2(V,root);

% Minimal polynomium:
minPol = 1;
for i=1:length(b)
    minPol = minPol * (X+b(i));
end
 
% Substitute all exponential forms with polynomial form and reduce:
while degree(subs(minPol,X,1)) > m
    minPol = subs(minPol,E,P);
    minPol = expand(minPol);
end

% Modulo 2:
minPol = mod2partly(minPol);
end
\end{lstlisting}

\codeTitle \ref{lst:minimumPoly} calls a function, called \code{degree}, shown in \codeTitle \ref{lst:degree}.
This will return the degree of the input equation.

\begin{lstlisting}[caption=Degree, style=Code-Matlab, label=lst:degree]
function d = degree(eq)
% Returns the maximum degree of the input equation.
% d = degree(eq)
%
% Note: Only accepts an equation with elements with only one '^'.
a = strtrim(strsplit(char(eq),'+'));
d = 0;
for i=1:length(a)
    f = strsplit(char(a(i)),'^');
    if length(f) == 2
        if d < double(sym(f(2)))
            d = double(sym(f(2)));
        end
    end
end
end
\end{lstlisting}


\begin{lstlisting}[caption=Mod2Partly, style=Code-Matlab, label=lst:•]
function y = mod2partly(eq)
% Returns the input equation, where each element is modulo 2. Matlab mod
% function does not work if an element consist of 3 multiplicated symbolic
% values. This does. 
% y = mod2partly(eq)
% Only accepts a single equation. Not a vector.
a = strtrim(strsplit(char(eq),'+'));
y = 0;
for i=1:length(a)
    tmp = 1;
    
    b = strtrim(strsplit(char(a(i)),'*'));
    if length(b) == 3
        tmp = mod(sym(char(b(1)))*sym(char(b(2))),2);
        tmp = mod(sym(char(b(3)))*tmp,2);
    else
        for j=1:length(b)
            tmp = tmp*sym(char(b(j)));
        end
    end
    
    R = mod(sym(char(tmp)),2);
    y = y + R;
end
end
\end{lstlisting}



\begin{lstlisting}[caption=Conjugate roots, style=Code-Matlab, label=lst:•]
function b = conjugateRoots2(V,root)
% Returns all the conjugated roots, given one root.
% b = conjugateRoots(root,m).
% V = vector from gfPol2Table(...)
% root = the root to be used

syms a;
base = length(V(:,1))-1;

a = strtrim(strsplit(char(root),'^')); %Find x in a^x
col = [1];
if length(a(1,:)) > 1
    col = [sym(a(1,2))];
end
root = sym(col(1,1));

%Find values of root
for i=1:length(V(1,:))
    %(alpha^root)^(2^l) = alpha^(root*2^l)
    value = root*(2^i);
    
    %modulo of vector messages gives the rest value
	tmp = mod(value, base);
	
    %Is this in the collection, col?
	flag = 0;
    for j = 1:length(col(1,:))
       if (col(1,j) == tmp) && (flag == 0)
           flag = 1;
       end
    end
    
    %If not, add it
    if flag == 0
        col(1,end+1) = tmp;
	end
end
syms a;
b(1,1) = a;
for i = 1:length(col(1,:))
   b(1,i) = a^sym(col(1,i));
end

end
\end{lstlisting}





































\end{document}