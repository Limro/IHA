Arbitrarily interleaving atomic statements
	- Process one does one thing, next process does something

Non-determinism
	- 2 statements from any 2 processes may or may not execute truly parallel.
	- Changing time will change concurrency processes
	- Distributed computer have their own time stamp. These must be send around or shared.
	- No common time must be send around
	- One cannot observe the system's GLOBALE state (all processes)
		- Only if you turn it off
	- Best to do is constructed images of state that may have existed

Channels
	- You can lose data because of different routing
	- Things can be reordered due to delay


LTL
====

Always 		En firkant - "for any time, t, in the future"
Eventually 	En ruder - "for some time, t, in the future"
not:		!,	
and:		&&,	
or:			||,	
implies:	->,	
equivalent:	<->	
always:		[],	
eventually	<>,	
until:		U


Patterns
========

Invariance: []p
	- p is always true

latching: <>[]p
	- Eventually p is always true

Infinitely often: [] <>p
	- Will always switch back and forth

ltl commands:
=============

Overtaking: ltl otk {
[](ptry->(!qcsU(qcsU(!qcsU pcs))))
}


Lifeness:
	- eventually p, means
		- ? -> ? -> p -> ? -> ?...
	- Now it will try to find
		- !p -> !p -> !p -> !p -> !p ...

Weak fairness:
	- If there's a choise of !p and p, then !p will be chosen


Array syntax
============

- int a[5] 
	is like a[0] to a[4]
- No for loop can assign values
- Multidimentional arrays are not allowed
- Be carefull - it will blow up the program

Records (L4S5)
=======
- Like structs
- Be careful - it will blow up the program

Symbolic names (L4S6)
==============
- Max 244
- Bruges som reference

Sparse arrays
=============
- Only stores value not equal '0'

Channels
========
- Communication channels used to model distributed systems
- Sends or receive messages
	- ch !e
		Send 'e' on channel ch (push())
	- ch = e
		Receive 'e' on channel ch (pop())

If there's only one process:
chan c = [0] of byte:
...
c! 1 /* Deadlock, since only one process */
...

/**/
chan c = [1] of byte
...
c! 1 /* Will run pass, since the channel now is a buffer */

- Anyone can receive a channel.
	To come around this, create a channel within a proctype, and a channel of [0] byte in another, and send the first channel as a buffer. (L4S15)
- A channel can be a buffer

- Rendezvous (run-devu') is capacity = 0
- Buffered is capacity > 0

- Do a request-Reply (S4L19)


Random receive (L4S25-26)
--------------
- Returns the first element in buffer that matches'e'.

- Without removing:
ch ? <e> //Assign first value 

ch ? [e] //The first is, return true
ch ?? [e] //Any such is, return true






